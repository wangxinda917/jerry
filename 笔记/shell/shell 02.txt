规范的shell脚本
1,声明解释器
2,注释
3,代码

bash优点,历史记录,tab键,快捷键,管道,重定向
变量:
1,自定义变量, 变量名称=变量的值
2,环境变量,USER UID HOSTNAME PWD HOME SHELL PS1 PS2
3,位置变量与预定义变量
    $1 $2 $3.... $#  $*  $0  $$  $?
变量扩展:
""    ''     ``  $()
read -p "XXXXX"  n
stty -echo
stty  echo
局部变量升级为全局变量 export
------------------------------------------------
运算
1, expr 1 + 2    expr 2 \* 2
2, echo $[1+1]  echo $((1+1))
3, let 不显示结果 ,对变量自增减, 创建变量
	let a++   let a--
	let a+=   let a-=
4,bc
	echo "1.1+1" | bc
	echo "scale=4;10/3" | bc
=================================
条件测试, 使脚本具备智能判断的工具
方法1  test 表达式  
方法2  [ 表达式 ] 
----------------------------------
1,字符串测试   ==  测试是否相等
test a == a   常量测试
echo $?		  返回值是0 ,表示上一条的测试成功
test a == b
echo $?		  返回值是非0 ,表示上一条的测试失败
[ a == a ]   测试字符串两边都要有空格
echo $?
[ a == b ]
echo $?
---------------------------------------
a=abc
[ $a == abc ]   变量测试
echo $?

[ $USER == root ]   测试当前用户是否为管理员
--------------------------------------
!=   测试是否不相等
[ a != b ]   是否不相等
echo $?    结果是0
--------------------------------------
-z  测试变量是否为空
a=abc 
[ -z $a ] 
echo $?     结果为非0 
[ -z $aa ]  
echo $?     结果为0
=======================
逻辑组合
&&  并且    符号前面的任务执行成功后才执行后面的任务
||     或者    符号前面的任务执行失败后才执行后面的任务

ls && ls
ls || ls
ls abcd && ls
ls abcd || ls

[ $USER != root ] && exit   如果不是管理员就退出
[ $USER == root ] || exit   如果不是管理员就退出
[ -z $a ] && exit  如果变量a是空值,就退出
------------------------------------
多个逻辑符号组合
ls && ls && ls
ls && ls || ls
ls || ls && ls
[ $USER == root ] && echo "你是管理员"  || echo "你不是管理员"
--------------------------
2,数字
-eq  等于
-ne  不等于
-gt  大于
-ge  大于等于
-lt  小于
-le  小于等于
-------------------------------
a=10
b=20
[ $a -eq $b ] && echo "相等" || echo "不相等"
[ 1 -eq 1 ] && echo "相等" || echo "不相等"
[ $a -gt $b ] && echo "ok" || echo "no"
[ $a -le $b ] && echo "ok" || echo "no"
===================================
编写脚本, 每2分钟检查登录服务器的用户数量,如果超过3人,发邮件通知管理员
vim /opt/test1.sh
#!/bin/bash
n=`who |wc -l`
[ $n -gt 3 ] && echo "有人入侵服务器,隔壁老王来了!"  | mail -s test root

之后赋予脚本执行权限
chmod +x /opt/test1.sh
然后在计划任务中添加
crontab -e
*/2 * * * * /opt/test1.sh
---------------------------------------------------
3,文件的测试
-e 文件是否存在
-f 文件是否存在,且是普通文件
-d 文件是否存在,且是目录
-r 读
-w 写
-x 执行

[ -e abc ]   测试abc是否存在 ,不关心文件类型
[ -f abc ]   测试abc是否存在 ,且必须是普通文件
[ -d abc ]   测试abc是否存在 ,且必须是目录
[ -r abc ]   测试当前用户对abc是否有读权限
[ -w abc ]   测试当前用户对abc是否有写权限
[ -x abc ]   测试当前用户对abc是否有执行权限

===========================================
if 判断
1, 单分支
if 条件测试 ;then
	执行指令1
fi
---------------------------

2,双分支
if 条件测试 ;then
	执行指令1
	else
	执行指令2
fi
-------------------------------------
#!/bin/bash
ping -c 3 -i 0.2 -W 1 $1 &> /dev/null
if [ $? -eq 0 ];then
        echo "通了"
else
        echo "不通"
fi
------------------------------
3,多分支
if 条件测试 ;then
	执行指令1
elif 条件测试 ;then
	执行指令2
	else
	执行指令3
fi
----------------------------------------------
#!/bin/bash
x=$[RANDOM%3]
read -p "请输入一个数字(0-2)" n
if [ $x -eq $n ] ;then
        echo "恭喜!猜对了!"
elif [ $x -lt $n ] ;then
        echo "猜大了!"
else
        echo "猜小了!"
fi
==============================
for循环,可以定义多次反复执行某任务的工具
for 变量名称 in 值1 值2 值3 ....
do
	执行任务
done
----------------
#!/bin/bash
for i in {1..10}
do
        echo $i
done
----------------
#!/bin/bash
a=10
for i in `seq $a`
do
        echo $i
done
-------------------------------------------------
#!/bin/bash
x=0
y=0
for i in {1..15}
do
	ping -c 3 -i 0.2 -W 1 172.25.0.$i &> /dev/null
	if [ $? -eq 0 ];then
		echo "172.25.0.$i通了"
		let x++
	else
		echo "172.25.0.$i不通"
		let y++
	fi
done
echo "$x台通了,$y台不通"
--------------------------------------------------












































